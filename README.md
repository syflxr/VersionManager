# VersionManager
有这样一种场景，某个项目的每个用户都是发一套自己的智能合约，并且是可升级的，用户希望自己能掌握是否升级的主动权。这就像应用商店的各类app,或者手机的系统，经常会发布新版本，但是有些用户追求稳定并不想升级，有些用户想尝鲜选择升级。这两年随着layer2的兴起，用户支付的gas费比在以太坊主网低的多，而且账户抽象正在尝试为用户屏蔽区块链的复杂性，有这些作为基础，未来可能会有更多功能丰富的dapp产生，那么刚刚提到的这种场景也会越来越频繁地出现。我近期在公司的某个项目中，正好碰到了这样的需求，在此做一番整理，希望能够抛砖引玉。

我们都知道，一个智能合约的字节码大小是有限制的，因此一个业务比较复杂的项目，最后会由多个智能合约组成。如果业务需要更新迭代，那么会有若干合约发生变化，也可能会移除某个合约，或新增某个合约，示意图如下（本文暂时只考虑了透明代理的情况）：
![1772262197734](https://github.com/user-attachments/assets/b3cb967c-e458-4ad0-9b3b-fb913c2747bc)

在此过程中，稍不小心出错就会带来巨大的麻烦，例如新合约storage slot冲突，升级时传错了实现合约地址，传错了data等等，尤其是用户量大的时候，避免升级出错显得尤为重要。

本文尝试通过新增一个版本管理合约(VersionManager.sol)，并改造openzeppelin的透明代理中的ProxyAdmin合约（改为ProxyAdminWithVersion），来解决上述疑难杂症，并且对于任何基于透明代理的项目，都能迁移到这套新方案。

项目方在VersionManager合约中发布项目的新版本，并且在新版本发布后有一个测试周期，在测试周期结束前，项目方可以修改版本的相关信息（比如突然测出来了什么bug）。在测试周期结束之后，项目方不再能修改该版本的信息，如若再发现bug，只能废弃该版本。用户在测试周期结束之后，才能升级到这个版本。下方的结构体是版本信息。
```solidity
    struct VersionInfoParams{
        address[] implList;//该项目需要用到的所有合约的实现，不管升级与否都要放进来
        uint[] contractIds;//每个合约又一个自己的id
        bytes4[] functionSigs;//如果升级的同时需要调用某个函数，把签名传进来 ，bytes4(keccak256(...))，否则占位即可
        bytes[] datas;//如果调用函数的数据不能用户自定义，这儿要传data，否则占位即可
        uint[] values;//如果涉及到native token，这儿传，否则传0
        uint delayTime;//发布该版本后需要等待的测试时间
        uint operation;//发布该版本是出于什么目的，是新增还是更新
        bytes32 description;//升级描述的hash值
    }
```
用户通过ProxyAdminWithVersion合约与VersionManager合约交互，完成注册初始版本，升级版本等操作。注册初始版本的原因主要是参与时间不同的用户的初始合约可能不一样，比如用户A参与该项目早，他的初始代码是版本1，用户B参与该项目晚，他的初始代码是本本3。

更详细的内容见该项目中的代码，这个项目基于hardhat框架，包括合约的代码和一个typescript编写的使用例子（非测试用例)。目前还很粗糙，后续会改造为foundry项目并提供测试用例。
